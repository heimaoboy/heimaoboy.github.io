<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>the blog of heimao</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="goroutine and channelgoroutine的本质是协程，是实现并行计算的核心。goroutine使用方式非常的简单，只需使用go关键字即可启动一个协程，并且它是处于异步方式运行，你不需要等它运行完成以后在执行以后的代码。 goroutine内部原理并发 一个cpu上能同时执行多项任务，在很短时间内，cpu来回切换任务执行(在某段很短时间内执行程序a，然后又迅速得切换到程序b去执">
<meta property="og:type" content="article">
<meta property="og:title" content="the blog of heimao">
<meta property="og:url" content="http://example.com/2022/10/08/goroutine%20and%20channel/index.html">
<meta property="og:site_name" content="the blog of heimao">
<meta property="og:description" content="goroutine and channelgoroutine的本质是协程，是实现并行计算的核心。goroutine使用方式非常的简单，只需使用go关键字即可启动一个协程，并且它是处于异步方式运行，你不需要等它运行完成以后在执行以后的代码。 goroutine内部原理并发 一个cpu上能同时执行多项任务，在很短时间内，cpu来回切换任务执行(在某段很短时间内执行程序a，然后又迅速得切换到程序b去执">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-10-08T02:00:30.034Z">
<meta property="article:modified_time" content="2022-10-08T02:03:01.545Z">
<meta property="article:author" content="hei mao">
<meta name="twitter:card" content="summary">
  
    <link rel="alternative" href="/atom.xml" title="the blog of heimao" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/heimao.png">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  

  
<script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>

  
<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>


  
<meta name="generator" content="Hexo 6.3.0"></head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
				<img lazy-src="/img/heimao.png" class="js-avatar">
			
		</a>

		<hgroup>
			<h1 class="header-author"><a href="/">hei mao</a></h1>
		</hgroup>

		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">Home</a></li>
				        
							<li><a href="/archives">Archives</a></li>
				        
						</ul>
					</nav>
					<nav class="half-header-menu">
						<a class="hide">Home</a>
						<a>Tags</a>
						<a>Links</a>
						<a>About</a>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
						</div>
						<!-- music -->
						
							<!-- <div style="position: absolute; bottom: 120px; left: auto; width: 85%;"> -->
							<div style="position: absolute; left: auto; width: 85%;">
								<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=220 height=86 src="//music.163.com/outchain/player?type=2&id=1846512883&auto=1&height=66"></iframe>
							</div>
						
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/heimaoboy">github</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">I want my life to be simple.</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide"></h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/img/heimao.png" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author"></h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">Home</a></li>
		        
					<li><a href="/archives">Archives</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-goroutine and channel" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2022/10/08/goroutine%20and%20channel/" class="article-date">
  	<time datetime="2022-10-08T02:00:30.034Z" itemprop="datePublished">2022-10-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<h2 id="goroutine-and-channel"><a href="#goroutine-and-channel" class="headerlink" title="goroutine and channel"></a>goroutine and channel</h2><p>goroutine的本质是协程，是实现并行计算的核心。goroutine使用方式非常的简单，只需使用go关键字即可启动一个协程，并且它是处于异步方式运行，你不需要等它运行完成以后在执行以后的代码。</p>
<h2 id="goroutine内部原理"><a href="#goroutine内部原理" class="headerlink" title="goroutine内部原理"></a>goroutine内部原理</h2><p><strong>并发</strong></p>
<p>一个cpu上能同时执行多项任务，在很短时间内，cpu来回切换任务执行(在某段很短时间内执行程序a，然后又迅速得切换到程序b去执行)，有时间上的重叠（宏观上是同时的，微观仍是顺序执行）,这样看起来多个任务像是同时执行，这就是并发。</p>
<p><strong>并行</strong></p>
<p>当系统有多个CPU时,每个CPU同一时刻都运行任务，互不抢占自己所在的CPU资源，同时进行，称为并行。</p>
<p><strong>进程</strong></p>
<p>cpu在切换程序的时候，如果不保存上一个程序的状态（也就是我们常说的context–上下文），直接切换下一个程序，就会丢失上一个程序的一系列状态，于是引入了进程这个概念，用以划分好程序运行时所需要的资源。因此进程就是一个程序运行时候的所需要的基本资源单位（也可以说是程序运行的一个实体）。</p>
<p><strong>线程</strong></p>
<p>cpu切换多个进程的时候，会花费不少的时间，因为切换进程需要切换到内核态，而每次调度需要内核态都需要读取用户态的数据，进程一旦多起来，cpu调度会消耗一大堆资源，因此引入了线程的概念，线程本身几乎不占有资源，他们共享进程里的资源，内核调度起来不会那么像进程切换那么耗费资源。</p>
<p><strong>协程</strong></p>
<p>协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。因此，协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置。线程和进程的操作是由程序触发系统接口，最后的执行者是系统；协程的操作执行者则是用户自身程序，goroutine也是协程。</p>
<h2 id="调度模型介绍"><a href="#调度模型介绍" class="headerlink" title="调度模型介绍"></a>调度模型介绍</h2><p>groutine能拥有强大的并发实现是通过GPM调度模型实现，下面就来解释下goroutine的调度模型。</p>
<p>Go的调度器内部有四个重要的结构：M，P，S，Sched。<br>M:M代表内核级线程，一个M就是一个线程，goroutine就是跑在M之上的；M是一个很大的结构，里面维护小对象内存cache（mcache）、当前执行的goroutine、随机数发生器等等非常多的信息<br>G:代表一个goroutine，它有自己的栈，instruction    pointer和其他信息（正在等待的channel等等），用于调度。<br>P:P全称是Processor，处理器，它的主要用途就是用来执行goroutine的，所以它也维护了一个goroutine队列，里面存储了所有需要它来执行的goroutine Sched：代表调度器，它维护有存储M和G的队列以及调度器的一些状态信息等。 </p>
<p><strong>调度实现</strong></p>
<p>P的数量可以通过GOMAXPROCS()来设置，它其实也就代表了真正的并发度，即有多少个goroutine可以同时运行。<br>图中灰色的那些goroutine并没有运行，而是出于ready的就绪态，正在等待被调度。P维护着这个队列（称之为runqueue），<br>Go语言里，启动一个goroutine很容易：go    function 就行，所以每有一个go语句被执行，runqueue队列就在其末尾加入一个<br>goroutine，在下一个调度点，就从runqueue中取出（如何决定取哪个goroutine？）一个goroutine执行。<br>当一个OS线程M0陷入阻塞时（如下图)，P转而在运行M1，图中的M1可能是正被创建，或者从线程缓存中取出。<br>当MO返回时，它必须尝试取得一个P来运行goroutine，一般情况下，它会从其他的OS线程那里拿一个P过来，<br>如果没有拿到的话，它就把goroutine放在一个global runqueue里，然后自己睡眠（放入线程缓存里）。所有的P也会周期性的检查global runqueue并运行其中的goroutine，否则global runqueue上的goroutine永远无法执行。  另一种情况是P所分配的任务G很快就执行完了（分配不均），这就导致了这个处理器P很忙，但是其他的P还有任务，此时如果global    runqueue没有任务G了，那么P不得不从其他的P里拿一些G来执行。一般来说，如果P从其他的P那里要拿任务的话，一般就拿run queue的一半，这就确保了每个OS线程都能充分的使用。</p>
<h2 id="使用goroutine"><a href="#使用goroutine" class="headerlink" title="使用goroutine"></a>使用goroutine</h2><p><strong>基本使用</strong></p>
<p>设置goroutine运行的CPU数量，最新版本的go已经默认已经设置了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num := runtime.NumCPU()    //获取主机的逻辑CPU个数</span><br><span class="line">runtime.GOMAXPROCS(num)    //设置可同时执行的最大CPU数</span><br></pre></td></tr></table></figure>

<p>使用示例</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cal</span><span class="params">(a <span class="type">int</span> , b <span class="type">int</span> )</span></span>  &#123;</span><br><span class="line">    c := a+b</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d + %d = %d\n&quot;</span>,a,b,c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">　　</span><br><span class="line">    <span class="keyword">for</span> i :=<span class="number">0</span> ; i&lt;<span class="number">10</span> ;i++&#123;</span><br><span class="line">        <span class="keyword">go</span> cal(i,i+<span class="number">1</span>)  <span class="comment">//启动10个goroutine 来计算</span></span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(time.Second * <span class="number">2</span>) <span class="comment">// sleep作用是为了等待所有任务完成</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><strong>goroutine异常捕捉</strong></p>
<p>当启动多个goroutine时，如果其中一个goroutine异常了，并且我们并没有对进行异常处理，那么整个程序都会终止，所以我们在编写程序时候最好每个goroutine所运行的函数都做异常处理，异常处理采用recover</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addele</span><span class="params">(a []<span class="type">int</span> ,i <span class="type">int</span>)</span></span>  &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;    <span class="comment">//匿名函数捕获错误</span></span><br><span class="line">        err := <span class="built_in">recover</span>()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;add ele fail&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">   a[i]=i</span><br><span class="line">   fmt.Println(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    Arry := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">for</span> i :=<span class="number">0</span> ; i&lt;<span class="number">10</span> ;i++&#123;</span><br><span class="line">        <span class="keyword">go</span> addele(Arry,i)</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>同步的goroutine</strong></p>
<p>由于goroutine是异步执行的，那很有可能出现主程序退出时还有goroutine没有执行完，此时goroutine也会跟着退出。此时如果想等到所有goroutine任务执行完毕才退出，go提供了sync包和channel来解决同步问题，当然如果你能预测每个goroutine执行的时间，你还可以通过time.Sleep方式等待所有的groutine执行完成以后在退出程序(如上面的列子)。</p>
<p>示例一：使用sync包同步goroutine sync大致实现方式 WaitGroup 等待一组goroutinue执行完毕.    主程序调用 Add 添加等待的goroutinue数量. 每个goroutinue在执行结束时调用 Done ，此时等待队列数量减1.，主程序通过Wait阻塞，直到等待队列为0.  </p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cal</span><span class="params">(a <span class="type">int</span> , b <span class="type">int</span> ,n *sync.WaitGroup)</span></span>  &#123;</span><br><span class="line">    c := a+b</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d + %d = %d\n&quot;</span>,a,b,c)</span><br><span class="line">    <span class="keyword">defer</span> n.Done() <span class="comment">//goroutinue完成后, WaitGroup的计数-1</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> go_sync sync.WaitGroup <span class="comment">//声明一个WaitGroup变量</span></span><br><span class="line">    <span class="keyword">for</span> i :=<span class="number">0</span> ; i&lt;<span class="number">10</span> ;i++&#123;</span><br><span class="line">        go_sync.Add(<span class="number">1</span>) <span class="comment">// WaitGroup的计数加1</span></span><br><span class="line">        <span class="keyword">go</span> cal(i,i+<span class="number">1</span>,&amp;go_sync)  </span><br><span class="line">    &#125;</span><br><span class="line">    go_sync.Wait()  <span class="comment">//等待所有goroutine执行完毕</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>示例二：通过channel实现goroutine之间的同步。</strong></p>
<p>实现方式：通过channel能在多个groutine之间通讯，当一个goroutine完成时候向channel发送退出信号,等所有goroutine退出时候，利用for循环channe去channel中的信号，若取不到数据会阻塞原理，等待所有goroutine执行完毕，使用该方法有个前提是你已经知道了你启动了多少个goroutine。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">cal</span><span class="params">(a <span class="type">int</span> , b <span class="type">int</span> ,Exitchan <span class="keyword">chan</span> <span class="type">bool</span>)</span></span>  &#123;</span><br><span class="line">    c := a+b</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d + %d = %d\n&quot;</span>,a,b,c)</span><br><span class="line">    time.Sleep(time.Second*<span class="number">2</span>)</span><br><span class="line">    Exitchan &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    Exitchan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>,<span class="number">10</span>)  <span class="comment">//声明并分配管道内存</span></span><br><span class="line">    <span class="keyword">for</span> i :=<span class="number">0</span> ; i&lt;<span class="number">10</span> ;i++&#123;</span><br><span class="line">        <span class="keyword">go</span> cal(i,i+<span class="number">1</span>,Exitchan)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> j :=<span class="number">0</span>; j&lt;<span class="number">10</span>; j++&#123;   </span><br><span class="line">         &lt;- Exitchan  <span class="comment">//取信号数据，如果取不到则会阻塞</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(Exitchan) <span class="comment">// 关闭管道</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>goroutine之间的通讯</strong></p>
<p>goroutine本质上是协程，可以理解为不受内核调度，而受go调度器管理的线程。goroutine之间可以通过channel进行通信或者说是数据共享，当然你也可以使用全局变量来进行数据共享。</p>
<p>示例：使用channel模拟消费者和生产者模式</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Productor</span><span class="params">(mychan <span class="keyword">chan</span> <span class="type">int</span>,data <span class="type">int</span>,wait *sync.WaitGroup)</span></span>  &#123;</span><br><span class="line">    mychan &lt;- data</span><br><span class="line">    fmt.Println(<span class="string">&quot;product data：&quot;</span>,data)</span><br><span class="line">    wait.Done()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Consumer</span><span class="params">(mychan <span class="keyword">chan</span> <span class="type">int</span>,wait *sync.WaitGroup)</span></span>  &#123;</span><br><span class="line">     a := &lt;- mychan</span><br><span class="line">    fmt.Println(<span class="string">&quot;consumer data：&quot;</span>,a)</span><br><span class="line">     wait.Done()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    datachan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">100</span>)   <span class="comment">//通讯数据管道</span></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> Productor(datachan, i,&amp;wg) <span class="comment">//生产数据</span></span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ &#123;</span><br><span class="line">        <span class="keyword">go</span> Consumer(datachan,&amp;wg)  <span class="comment">//消费数据</span></span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><p><strong>简介</strong></p>
<p>channel俗称管道，用于数据传递或数据共享，其本质是一个先进先出的队列，使用goroutine+channel进行数据通讯简单高效，同时也线程安全，多个goroutine可同时修改一个channel，不需要加锁。</p>
<p>channel可分为三种类型：</p>
<p>只读channel：只能读channel里面数据，不可写入</p>
<p>只写channel：只能写数据，不可读</p>
<p>一般channel：可读可写</p>
<p><strong>channel使用</strong></p>
<p>定义和声明</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> readOnlyChan &lt;-<span class="keyword">chan</span> <span class="type">int</span>            <span class="comment">// 只读chan</span></span><br><span class="line"><span class="keyword">var</span> writeOnlyChan <span class="keyword">chan</span>&lt;- <span class="type">int</span>           <span class="comment">// 只写chan</span></span><br><span class="line"><span class="keyword">var</span> mychan  <span class="keyword">chan</span> <span class="type">int</span>                     <span class="comment">//读写channel</span></span><br><span class="line"><span class="comment">//定义完成以后需要make来分配内存空间，不然使用会deadlock</span></span><br><span class="line">mychannel = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">read_only := <span class="built_in">make</span> (&lt;-<span class="keyword">chan</span> <span class="type">int</span>,<span class="number">10</span>)<span class="comment">//定义只读的channel</span></span><br><span class="line">write_only := <span class="built_in">make</span> (<span class="keyword">chan</span>&lt;- <span class="type">int</span>,<span class="number">10</span>)<span class="comment">//定义只写的channel</span></span><br><span class="line">read_write := <span class="built_in">make</span> (<span class="keyword">chan</span> <span class="type">int</span>,<span class="number">10</span>)<span class="comment">//可同时读写</span></span><br></pre></td></tr></table></figure>

<p> 读写数据</p>
<p>需要注意的是：</p>
<ul>
<li>管道如果未关闭，在读取超时会则会引发deadlock异常</li>
<li>管道如果关闭进行写入数据会pannic</li>
<li>当管道中没有数据时候再行读取或读取到默认值，如int类型默认值是0</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- <span class="string">&quot;wd&quot;</span>  <span class="comment">//写数据</span></span><br><span class="line">a := &lt;- ch <span class="comment">//读取数据</span></span><br><span class="line">a, ok := &lt;-ch  <span class="comment">//优雅的读取数据</span></span><br></pre></td></tr></table></figure>

<p>循环管道</p>
<p>需要注意的是：</p>
<ul>
<li>使用range循环管道，如果管道未关闭会引发deadlock错误。</li>
<li>如果采用for死循环已经关闭的管道，当管道没有数据时候，读取的数据会是管道的默认值，并且循环不会退出。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mychannel := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>,<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>;i &lt; <span class="number">10</span>;i++&#123;</span><br><span class="line">        mychannel &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(mychannel)  <span class="comment">//关闭管道</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;data lenght: &quot;</span>,<span class="built_in">len</span>(mychannel))</span><br><span class="line">    <span class="keyword">for</span>  v := <span class="keyword">range</span> mychannel &#123;  <span class="comment">//循环管道</span></span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;data lenght:  %d&quot;</span>,<span class="built_in">len</span>(mychannel))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>channel实现作业池</strong></p>
<p>我们创建三个channel，一个channel用于接受任务，一个channel用于保持结果，还有个channel用于决定程序退出的时候。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Task</span><span class="params">(taskch, resch <span class="keyword">chan</span> <span class="type">int</span>, exitch <span class="keyword">chan</span> <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;   <span class="comment">//异常处理</span></span><br><span class="line">        err := <span class="built_in">recover</span>()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;do task error：&quot;</span>, err)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> t := <span class="keyword">range</span> taskch &#123; <span class="comment">//  处理任务</span></span><br><span class="line">        fmt.Println(<span class="string">&quot;do task :&quot;</span>, t)</span><br><span class="line">        resch &lt;- t <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line">    exitch &lt;- <span class="literal">true</span> <span class="comment">//处理完发送退出信号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    taskch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">20</span>) <span class="comment">//任务管道</span></span><br><span class="line">    resch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">20</span>)  <span class="comment">//结果管道</span></span><br><span class="line">    exitch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, <span class="number">5</span>) <span class="comment">//退出管道</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">            taskch &lt;- i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(taskch)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;  <span class="comment">//启动5个goroutine做任务</span></span><br><span class="line">        <span class="keyword">go</span> Task(taskch, resch, exitch)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">//等5个goroutine结束</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">            &lt;-exitch</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(resch)  <span class="comment">//任务处理完成关闭结果管道，不然range报错</span></span><br><span class="line">        <span class="built_in">close</span>(exitch)  <span class="comment">//关闭退出管道</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> res := <span class="keyword">range</span> resch&#123;  <span class="comment">//打印结果</span></span><br><span class="line">        fmt.Println(<span class="string">&quot;task res：&quot;</span>,res)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>只读channel和只写channel</strong></p>
<p>一般定义只读和只写的管道意义不大，更多时候我们可以在参数传递时候指明管道可读还是可写，即使当前管道是可读写的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//只能向chan里写数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(c <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        c &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//只能取channel中的数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">(c &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> c &#123;</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> send(c)</span><br><span class="line">    <span class="keyword">go</span> get(c)</span><br><span class="line">    time.Sleep(time.Second*<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>select-case实现非阻塞channel</strong></p>
<p>原理通过select+case加入一组管道，当满足（这里说的满足意思是有数据可读或者可写)select中的某个case时候，那么该case返回，若都不满足case，则走default分支。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(c <span class="keyword">chan</span> <span class="type">int</span>)</span></span>  &#123;</span><br><span class="line">    <span class="keyword">for</span> i :=<span class="number">1</span> ; i&lt;<span class="number">10</span> ;i++  &#123;</span><br><span class="line">     c &lt;-i</span><br><span class="line">     fmt.Println(<span class="string">&quot;send data : &quot;</span>,i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    resch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>,<span class="number">20</span>)</span><br><span class="line">    strch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>,<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">go</span> send(resch)</span><br><span class="line">    strch &lt;- <span class="string">&quot;wd&quot;</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> a := &lt;-resch:</span><br><span class="line">        fmt.Println(<span class="string">&quot;get data : &quot;</span>, a)</span><br><span class="line">    <span class="keyword">case</span> b := &lt;-strch:</span><br><span class="line">        fmt.Println(<span class="string">&quot;get data : &quot;</span>, b)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">&quot;no channel actvie&quot;</span>)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>channel频率控制</strong></p>
<p>在对channel进行读写的时，go还提供了非常人性化的操作，那就是对读写的频率控制，通过time.Ticke实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    requests:= <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span> ,<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;<span class="number">5</span>;i++&#123;</span><br><span class="line">        requests&lt;-i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(requests)</span><br><span class="line">    limiter := time.Tick(time.Second*<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> req:=<span class="keyword">range</span> requests&#123;</span><br><span class="line">        &lt;-limiter</span><br><span class="line">        fmt.Println(<span class="string">&quot;requets&quot;</span>,req,time.Now()) <span class="comment">//执行到这里，需要隔1秒才继续往下执行，time.Tick(timer)上面已定义</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    
  </div>
  
    
  
</article>






</div>
      <!-- <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2022 hei mao
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/preccrep/hexo-theme-jelly" target="_blank">Jelly</a>
        </div>
    </div>
  </div>
</footer> -->
    </div>
    
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">



<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>

<script src="/js/main.js"></script>




  </div>
</body>
</html>